// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package evms

import (
	"encoding/json"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/holiman/uint256"
)

var _ = (*revmStructLogMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (r revmStructLog) MarshalJSON() ([]byte, error) {
	type revmStructLog struct {
		Pc            uint64                      `json:"pc"`
		Op            vm.OpCode                   `json:"op"`
		Gas           math.HexOrDecimal64         `json:"gas"`
		GasCost       math.HexOrDecimal64         `json:"gasCost"`
		Memory        hexutil.Bytes               `json:"memory,omitempty"`
		MemorySize    math.HexOrDecimal64         `json:"memSize"`
		Stack         []hexutil.U256              `json:"stack"`
		ReturnData    hexutil.Bytes               `json:"returnData,omitempty"`
		Storage       map[common.Hash]common.Hash `json:"-"`
		Depth         int                         `json:"depth"`
		RefundCounter math.HexOrDecimal64         `json:"refund"`
		Err           error                       `json:"-"`
		OpName        string                      `json:"opName"`
	}
	var enc revmStructLog
	enc.Pc = r.Pc
	enc.Op = r.Op
	enc.Gas = math.HexOrDecimal64(r.Gas)
	enc.GasCost = math.HexOrDecimal64(r.GasCost)
	enc.Memory = r.Memory
	enc.MemorySize = math.HexOrDecimal64(r.MemorySize)
	if r.Stack != nil {
		enc.Stack = make([]hexutil.U256, len(r.Stack))
		for k, v := range r.Stack {
			enc.Stack[k] = hexutil.U256(v)
		}
	}
	enc.ReturnData = r.ReturnData
	enc.Storage = r.Storage
	enc.Depth = r.Depth
	enc.RefundCounter = math.HexOrDecimal64(r.RefundCounter)
	enc.Err = r.Err
	enc.OpName = r.OpName()
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (r *revmStructLog) UnmarshalJSON(input []byte) error {
	type revmStructLog struct {
		Pc            *uint64                     `json:"pc"`
		Op            *vm.OpCode                  `json:"op"`
		Gas           *math.HexOrDecimal64        `json:"gas"`
		GasCost       *math.HexOrDecimal64        `json:"gasCost"`
		Memory        *hexutil.Bytes              `json:"memory,omitempty"`
		MemorySize    *math.HexOrDecimal64        `json:"memSize"`
		Stack         []hexutil.U256              `json:"stack"`
		ReturnData    *hexutil.Bytes              `json:"returnData,omitempty"`
		Storage       map[common.Hash]common.Hash `json:"-"`
		Depth         *int                        `json:"depth"`
		RefundCounter *math.HexOrDecimal64        `json:"refund"`
		Err           error                       `json:"-"`
	}
	var dec revmStructLog
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Pc != nil {
		r.Pc = *dec.Pc
	}
	if dec.Op != nil {
		r.Op = *dec.Op
	}
	if dec.Gas != nil {
		r.Gas = uint64(*dec.Gas)
	}
	if dec.GasCost != nil {
		r.GasCost = uint64(*dec.GasCost)
	}
	if dec.Memory != nil {
		r.Memory = *dec.Memory
	}
	if dec.MemorySize != nil {
		r.MemorySize = int(*dec.MemorySize)
	}
	if dec.Stack != nil {
		r.Stack = make([]uint256.Int, len(dec.Stack))
		for k, v := range dec.Stack {
			r.Stack[k] = uint256.Int(v)
		}
	}
	if dec.ReturnData != nil {
		r.ReturnData = *dec.ReturnData
	}
	if dec.Storage != nil {
		r.Storage = dec.Storage
	}
	if dec.Depth != nil {
		r.Depth = *dec.Depth
	}
	if dec.RefundCounter != nil {
		r.RefundCounter = uint64(*dec.RefundCounter)
	}
	if dec.Err != nil {
		r.Err = dec.Err
	}
	return nil
}
