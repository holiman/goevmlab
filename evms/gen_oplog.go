// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package evms

import (
	"encoding/json"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/holiman/uint256"
)

var _ = (*opLogMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (o opLog) MarshalJSON() ([]byte, error) {
	type opLog struct {
		Pc         uint64              `json:"pc"`
		Op         vm.OpCode           `json:"op"`
		Gas        math.HexOrDecimal64 `json:"gas"`
		GasCost    math.HexOrDecimal64 `json:"gasCost"`
		Memory     hexutil.Bytes       `json:"memory,omitempty"`
		MemorySize math.HexOrDecimal64 `json:"memSize"`
		Stack      []hexutil.U256      `json:"stack"`
		ReturnData hexutil.Bytes       `json:"returnData,omitempty"`
		Depth      int                 `json:"depth"`
		Err        error               `json:"-"`
		StateRoot1 string              `json:"stateRoot"`
		StateRoot2 string              `json:"postHash"`
		OpName     string              `json:"opName"`
	}
	var enc opLog
	enc.Pc = o.Pc
	enc.Op = o.Op
	enc.Gas = math.HexOrDecimal64(o.Gas)
	enc.GasCost = math.HexOrDecimal64(o.GasCost)
	enc.Memory = o.Memory
	enc.MemorySize = math.HexOrDecimal64(o.MemorySize)
	if o.Stack != nil {
		enc.Stack = make([]hexutil.U256, len(o.Stack))
		for k, v := range o.Stack {
			enc.Stack[k] = hexutil.U256(v)
		}
	}
	enc.ReturnData = o.ReturnData
	enc.Depth = o.Depth
	enc.Err = o.Err
	enc.StateRoot1 = o.StateRoot1
	enc.StateRoot2 = o.StateRoot2
	enc.OpName = o.OpName()
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (o *opLog) UnmarshalJSON(input []byte) error {
	type opLog struct {
		Pc         *uint64              `json:"pc"`
		Op         *vm.OpCode           `json:"op"`
		Gas        *math.HexOrDecimal64 `json:"gas"`
		GasCost    *math.HexOrDecimal64 `json:"gasCost"`
		Memory     *hexutil.Bytes       `json:"memory,omitempty"`
		MemorySize *math.HexOrDecimal64 `json:"memSize"`
		Stack      []hexutil.U256       `json:"stack"`
		ReturnData *hexutil.Bytes       `json:"returnData,omitempty"`
		Depth      *int                 `json:"depth"`
		Err        error                `json:"-"`
		StateRoot1 *string              `json:"stateRoot"`
		StateRoot2 *string              `json:"postHash"`
	}
	var dec opLog
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Pc != nil {
		o.Pc = *dec.Pc
	}
	if dec.Op != nil {
		o.Op = *dec.Op
	}
	if dec.Gas != nil {
		o.Gas = uint64(*dec.Gas)
	}
	if dec.GasCost != nil {
		o.GasCost = uint64(*dec.GasCost)
	}
	if dec.Memory != nil {
		o.Memory = *dec.Memory
	}
	if dec.MemorySize != nil {
		o.MemorySize = int(*dec.MemorySize)
	}
	if dec.Stack != nil {
		o.Stack = make([]uint256.Int, len(dec.Stack))
		for k, v := range dec.Stack {
			o.Stack[k] = uint256.Int(v)
		}
	}
	if dec.ReturnData != nil {
		o.ReturnData = *dec.ReturnData
	}
	if dec.Depth != nil {
		o.Depth = *dec.Depth
	}
	if dec.Err != nil {
		o.Err = dec.Err
	}
	if dec.StateRoot1 != nil {
		o.StateRoot1 = *dec.StateRoot1
	}
	if dec.StateRoot2 != nil {
		o.StateRoot2 = *dec.StateRoot2
	}
	return nil
}
