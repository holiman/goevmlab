// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package evms

import (
	"encoding/json"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/holiman/uint256"
)

var _ = (*opLogMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (o opLog) MarshalJSON() ([]byte, error) {
	type opLog struct {
		Pc            uint64              `json:"pc"`
		Section       uint64              `json:"section,omitempty"`
		Op            math.HexOrDecimal64 `json:"op"`
		Gas           math.HexOrDecimal64 `json:"gas"`
		GasCost       math.HexOrDecimal64 `json:"gasCost"`
		Memory        hexutil.Bytes       `json:"memory,omitempty"`
		MemorySize    math.HexOrDecimal64 `json:"memSize"`
		Stack         []hexutil.U256      `json:"stack"`
		ReturnData    hexutil.Bytes       `json:"returnData,omitempty"`
		Depth         int                 `json:"depth"`
		FunctionDepth int                 `json:"functionDepth,omitempty"`
		Err           error               `json:"-"`
		StateRoot1    string              `json:"stateRoot"`
		StateRoot2    string              `json:"postHash"`
		OpName        string              `json:"opName"`
	}
	var enc opLog
	enc.Pc = o.Pc
	// Depends on Geth EOF support
	//enc.Section = o.Section
	enc.Op = math.HexOrDecimal64(o.Op)
	enc.Gas = math.HexOrDecimal64(o.Gas)
	enc.GasCost = math.HexOrDecimal64(o.GasCost)
	enc.Memory = o.Memory
	enc.MemorySize = math.HexOrDecimal64(o.MemorySize)
	if o.Stack != nil {
		enc.Stack = make([]hexutil.U256, len(o.Stack))
		for k, v := range o.Stack {
			enc.Stack[k] = hexutil.U256(v)
		}
	}
	enc.ReturnData = o.ReturnData
	enc.Depth = o.Depth
	// Depends on Geth EOF support
	//enc.FunctionDepth = o.FunctionDepth
	enc.Err = o.Err
	enc.StateRoot1 = o.StateRoot1
	enc.StateRoot2 = o.StateRoot2
	enc.OpName = o.OpName()
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (o *opLog) UnmarshalJSON(input []byte) error {
	type opLog struct {
		Pc            *uint64              `json:"pc"`
		Section       *uint64              `json:"section,omitempty"`
		Op            *math.HexOrDecimal64 `json:"op"`
		Gas           *math.HexOrDecimal64 `json:"gas"`
		GasCost       *math.HexOrDecimal64 `json:"gasCost"`
		Memory        *hexutil.Bytes       `json:"memory,omitempty"`
		MemorySize    *math.HexOrDecimal64 `json:"memSize"`
		Stack         []hexutil.U256       `json:"stack"`
		ReturnData    *hexutil.Bytes       `json:"returnData,omitempty"`
		Depth         *int                 `json:"depth"`
		FunctionDepth *int                 `json:"functionDepth,omitempty"`
		Err           error                `json:"-"`
		StateRoot1    *string              `json:"stateRoot"`
		StateRoot2    *string              `json:"postHash"`
	}
	var dec opLog
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Pc != nil {
		o.Pc = *dec.Pc
	}
	// Depends on Geth EOF support
	//if dec.Section != nil {
	//	o.Section = *dec.Section
	//} else {
	//	o.Section = 0
	//}
	if dec.Op != nil {
		o.Op = vm.OpCode(uint64(*dec.Op))
	}
	if dec.Gas != nil {
		o.Gas = uint64(*dec.Gas)
	}
	if dec.GasCost != nil {
		o.GasCost = uint64(*dec.GasCost)
	}
	if dec.Memory != nil {
		o.Memory = *dec.Memory
	}
	if dec.MemorySize != nil {
		o.MemorySize = int(*dec.MemorySize)
	}
	if dec.Stack != nil {
		o.Stack = make([]uint256.Int, len(dec.Stack))
		for k, v := range dec.Stack {
			o.Stack[k] = uint256.Int(v)
		}
	}
	if dec.ReturnData != nil {
		o.ReturnData = *dec.ReturnData
	}
	if dec.Depth != nil {
		o.Depth = *dec.Depth
	}
	// Depends on Geth EOF support
	//if dec.FunctionDepth != nil {
	//	o.FunctionDepth = *dec.FunctionDepth
	//} else {
	//	o.FunctionDepth = 0
	//}
	if dec.Err != nil {
		o.Err = dec.Err
	}
	if dec.StateRoot1 != nil {
		o.StateRoot1 = *dec.StateRoot1
	}
	if dec.StateRoot2 != nil {
		o.StateRoot2 = *dec.StateRoot2
	}
	return nil
}
